/**********************************************************************************************
*文件名：hal_pcf8563.c
*简介：RTC时钟芯片 PCF8563 驱动代码
*特殊说明：无
**********************************************************************************************/

//头文件
#include "pcf8563.h"
#include <string.h>
#include "hal_iic1.h"


//常数定义
#define PCF8563_ADDR			0xA2 			//PCF8563的IIC1地址

//常量定义
const uint8_t RTC_InitTime[7] = 					//默认出厂设置时间：年月日时分秒, BCD码格式
{
	0x20, 0x18, 0x08, 0x08, 0x15, 0x19, 0x00
};

const uint8_t RTC_NonLeapMonth[] = 				//平年对应的月份
{
	0,31,28,31,30,31,30,31,31,30,31,30,31
};

const uint8_t RTC_LeapMonth[] = 					//闰年对应的月份
{												//可被4整除但不可被100整除为
	0,31,29,31,30,31,30,31,31,30,31,30,31		//闰年而正百的年数必须是可以
};												//被400整除的才是闰年

//函数定义

/**********************************************************************************************
*函数：void PCF8563_ReadBytes(uint8_t address, uint8_t *buf, uint8_t count)
*功能：从PCF8563的寄存器地址address开始，读取count个数据，存放到buf指向的地址。
*输入：
*	uint8_t address,寄存器地址，从PCF8563的寄存器地址address开始读取
*	uint8_t *buf,指针，存放从PCF8563都回来的数据
*	uint8_t count,总共读取的数据个数
*输出：无
*特殊说明：无
**********************************************************************************************/
void PCF8563_ReadBytes(uint8_t address, uint8_t *buf, uint8_t count)
{
    uint8_t i;
    
    IIC1_WriteSlaveAddr(PCF8563_ADDR&0xFE);      //第0位清0表示写操作
    IIC1_WriteByte(address);
    
    IIC1_WriteSlaveAddr(PCF8563_ADDR|0x01);      //第0位置1表示读操作
    for(i=0;i<count;i++)
    {
        buf[i] = IIC1_ReadByte();
        if( i<(count-1))
        {
            IIC1_Ack();
        }
    }
    IIC1_NoAck();
    
    IIC1_Stop();
}

/**********************************************************************************************
*函数：void PCF8563_WriteByte(uint8_t address, uint8_t mdata)
*功能：往PCF8563的寄存器地址address写入数据mdata。
*输入：
*	uint8_t address,PCF8563的寄存器地址
*	uint8_t mdata,要写入的数据
*输出：无
*特殊说明：无
**********************************************************************************************/
void PCF8563_WriteByte(uint8_t address, uint8_t mdata)
{
    IIC1_WriteSlaveAddr(PCF8563_ADDR&0xFE);      //第0位清0表示写操作
    IIC1_WriteByte(address);
    IIC1_WriteByte(mdata);
    IIC1_Stop();
}

/**********************************************************************************************
*函数：void PCF8563_Start(void)
*功能：启动PCF8563
*输入：无
*输出：无
*特殊说明：无
**********************************************************************************************/                              
void PCF8563_Start(void)
{
	PCF8563_WriteByte(0x00, 0x00);              //第一个0x00为控制/状态寄存器1
}

/**********************************************************************************************
*函数：void PCF8563_GetTime(uint8_t *ptr)
*功能：从PCF8563中读取时间，读取到的内容包含年月日时分秒（BCD码格式）
*输入：uint8_t *ptr，指针，用于保存读取到时钟信息，占用7个字节。
*      读取到的时钟数据格式如下：（注意：数据格式是BCD码格式）
*-|----|-------------|------|------|------|------|------|-
* |数组|ptr[0]~ptr[1]|ptr[2]|ptr[3]|ptr[4]|ptr[5]|ptr[6]|
*-|----|-------------|------|------|------|------|------|-
* |解释|年         	 |月    | 日   |时    |分    |秒    |
*-|----|-------------|------|------|------|------|------|-
* |示例|0x2017       |0x12  |0x25  |0x12  |0x34  |0x56  |
*-|----|-------------|------|------|------|------|------|-
* |时钟|2017年       |12月  |25日  |12时  |34分  |56秒  |
*-|----|-------------|------|------|------|------|------|-
*输出：无
*特殊说明：无
**********************************************************************************************/                                 
void PCF8563_GetTime(uint8_t *ptr)
{
    uint8_t temp, i;
    for(i=0;i<2;i++)
    {
        PCF8563_ReadBytes(0x08, ptr+1, 1);      //年
        PCF8563_ReadBytes(0x07, ptr+2, 1);      //月
        PCF8563_ReadBytes(0x05, ptr+3, 1);      //日
        PCF8563_ReadBytes(0x04, ptr+4, 1);      //时
        PCF8563_ReadBytes(0x03, ptr+5, 1);      //分
        PCF8563_ReadBytes(0x02, ptr+6, 1);      //秒
        
        if((*(ptr+2))&0x80)                     //判断月寄存器中的世纪标志位
        {
            *(ptr+0) = 0x20;                    //当前时间为20XX年
        }
        else
        {
            *(ptr+0) = 0x19;                    //当前时间为19XX年
        }
        *(ptr+6) &= 0x7F;
        *(ptr+5) &= 0x7F;
        *(ptr+4) &= 0x3F;
        *(ptr+3) &= 0x3F;
        *(ptr+2) &= 0x1F;
        
        PCF8563_ReadBytes(0x03, &temp, 1);      //分
        if((temp&0x7F) == *(ptr+5))               //两次分不相等再读一次
        {
            break;
        }
    }
}

/**********************************************************************************************
*函数：void PCF8563_WirteTime(uint8_t *ptr)
*功能：往PCF8563中写入时间，要写入的内容包含年月日时分秒（BCD码格式）
*输入：uint8_t *ptr，指针，指向要写入的时间信息，占用7个字节。
*      要写入的时钟数据格式如下：（注意：数据格式是BCD码格式）
*-|----|-------------|------|------|------|------|------|-
* |数组|ptr[0]~ptr[1]|ptr[2]|ptr[3]|ptr[4]|ptr[5]|ptr[6]|
*-|----|-------------|------|------|------|------|------|-
* |解释|年         	 |月    | 日   |时    |分    |秒    |
*-|----|-------------|------|------|------|------|------|-
* |示例|0x2017       |0x12  |0x25  |0x12  |0x34  |0x56  |
*-|----|-------------|------|------|------|------|------|-
* |时钟|2017年       |12月  |25日  |12时  |34分  |56秒  |
*-|----|-------------|------|------|------|------|------|-
*输出：无
*特殊说明：无
**********************************************************************************************/    
void PCF8563_WirteTime(uint8_t *ptr)
{
    PCF8563_WriteByte(0x00, 0x20);              //让PCF8563时钟芯停止运行
    PCF8563_WriteByte(0x08, *(ptr+1));          //年
    
    if(*(ptr+0)==0x19)                          //时间为19XX年世纪标志位清0
    {
        PCF8563_WriteByte(0x07, (*(ptr+2)));    //月
    } 
    else                                        //时间为20XX年世纪标志位置1
    {
        PCF8563_WriteByte(0x07, (*(ptr+2))|0x80);
    }
    
    PCF8563_WriteByte(0x05, *(ptr+3));          //日
    PCF8563_WriteByte(0x04, *(ptr+4));          //时
    PCF8563_WriteByte(0x03, *(ptr+5));          //分
    PCF8563_WriteByte(0x02, *(ptr+6));          //秒
    PCF8563_Start();                            //让PCF8563时钟芯开始运行
}

/**********************************************************************************************
*函数：uint8_t PCF8563_Init(void)
*功能：对PCF8563进行初始化
*输入：无
*输出：时钟格式异常返回0，正常返回1
*特殊说明：如果读取的时间格式不对, 则重赋初始时间
**********************************************************************************************/ 
uint8_t PCF8563_Init(void)
{
    uint8_t ptr[7];
    
    PCF8563_Start();
    PCF8563_GetTime(ptr);
	PCF8563_GetTime(ptr);
	PCF8563_GetTime(ptr);
    
    if (*ptr !=0x20 || *(ptr+1)>0x99 || *(ptr+2)>0x12 || *(ptr+3)>0x31 || *(ptr+4)>0x24 || 
        *(ptr+5)>0x60 || *(ptr+6)>0x60 || *(ptr+2)==0   || *(ptr+3)==0 )
    {
        PCF8563_WirteTime((uint8_t *)RTC_InitTime);
		printf("日期格式不对，重设RTC时间\r\n");
        PCF8563_GetTime(ptr);
        if (*(ptr+1)>0x99 || *(ptr+2)>0x12 || *(ptr+3)>0x31 || *(ptr+4)>0x24 || 
            *(ptr+5)>0x60 || *(ptr+6)>0x60 || *(ptr+2)==0   || *(ptr+3)==0 )
        {
            return  0;
        }
    }
    PCF8563_Start();
#if 0
    PCF8563_WirteTime((uint8_t *)RTC_InitTime);//调试用，可屏蔽
	printf("设置RTC时间\r\n");
#endif
    return 1;
}

/**********************************************************************************************
*函数：uint8_t Convert_BcdToHex(uint8_t *bcd, uint8_t *hex)
*功能：将BCD码转换成常用的编码格式
*输入：
*		uint8_t *bcd, 指针，指向输入的BCD码
*		uint8_t *hex, 指针，转换结果将保存到这里。
*输出：返回值为0表示没进行转换, 为1表示转换成功
*特殊说明：如果读取的时间格式不对, 则重赋初始时间
**********************************************************************************************/ 
uint8_t Convert_BcdToHex(uint8_t *bcd, uint8_t *hex)
{
    if((*bcd & 0x0f)>0x09)
    {
        return 0;
    }
    if((*bcd & 0xf0)>0x90)
    {
        return 0;
    }
    
    *hex = (*bcd & 0x0f);
    *hex += ((*bcd) >> 4) *10;
    
    return 1;
}

/**********************************************************************************************
*函数：uint8_t Time_CheckValidity(uint8_t *rtc);
*功能：时间格式合法性检查
*输入：uint8_t *rtc，指针，指向待检查的时间数组
*输出：返回值为0表示不合法, 为1表示合法
*特殊说明：无
**********************************************************************************************/ 
uint8_t Time_CheckValidity(uint8_t *rtc)
{
    uint8_t  vrtc[8];
    uint8_t  ucLeapYearFlag=0, i;
    uint16_t year;
    
    for(i=0;i<7;i++)                                //将BCD码转换成二进制数
    {
         if(!Convert_BcdToHex (rtc+i, vrtc+i))
         {
            return 0;
         }
    }
    
    if(!((*vrtc==19)||(*vrtc==20)))                 //年合法性检查
    {
        return 0;
    }
    year = *vrtc * 100 + *(vrtc+1);
    
    if((year%4)==0)                                 //闰年/平年计算
    {
        if((year%100)!=0)
        {
            ucLeapYearFlag = 1;
        }
        else if((year%400)==0)
        {
            ucLeapYearFlag = 1;
        }
    }
    
    if((*(vrtc+2)>12)||(*(vrtc+2)==0))              //月合法性检查
    {
        return 0;
    }
    
    if((*(vrtc+3))==0)                             //日合法性检查
    {
        return 0;
    }
    
    if( ucLeapYearFlag )                            //闰年对应的月份的检查
    {
        if(*(vrtc+3)>RTC_LeapMonth[*(vrtc+2)])
        {
            return 0;
        }
    }
    else                                            //平年对应的月份的检查
    {
        if(*(vrtc+3)>RTC_NonLeapMonth[*(vrtc+2)])
        {
            return 0;
        }
    }
    
    if (*(vrtc+4)>=24)                              //时合法性检查
    {
        return 0;
    }
    
    if (*(vrtc+5)>=60)                              //分合法性检查
    {
        return 0;
    }
    
    if (*(vrtc+6)>=60)                              //秒合法性检查
    {
        return 0;
    }
    
    return 1;
}
